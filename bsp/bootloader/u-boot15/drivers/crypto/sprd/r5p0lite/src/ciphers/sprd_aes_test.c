/*
* Copyright (c) 2016, Spreadtrum Communications.
*
* The above copyright notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#include <sprd_crypto.h>
#include <sprd_aes.h>
//#include <lib/console.h>
//#include <platform.h>

#ifdef CE_PERFORMANCE_TEST
sprd_crypto_err_t sprd_aes_speed_test_ecb (void) {
	static const struct {
		uint32_t key_len;
		uint32_t pt_len;
		uint32_t msg_len;
		int32_t padding;
		const uint8_t key[32] __attribute__ ((aligned (8)));
		const uint8_t pt[192] __attribute__ ((aligned (8)));
		const uint8_t ct[192] __attribute__ ((aligned (8)));
	} tests[] = {
		{/* 32 bytes pt, 128 bits key, nopad */
			16, 32, 1024, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0xdb, 0x7c, 0xe6, 0x7a, 0xf1, 0x3d, 0xe5, 0x7a,
			  0x95, 0xd9, 0x22, 0xe5, 0x32, 0x5a, 0xbf, 0x13,
			  0x77, 0x10, 0x98, 0xa6, 0xb7, 0x8c, 0xb4, 0x5c,
			  0x02, 0x9c, 0xf1, 0xc0, 0xdd, 0xee, 0x0f, 0x1b} ,
		},
		{/* 32 bytes pt, 192 bits key, nopad */
			24, 32, 102400, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x31, 0x6c, 0xe2, 0x04, 0x25, 0x64, 0x03, 0x57,
			  0x66, 0x45, 0x4d, 0xdf, 0x7c, 0x1a, 0x50, 0x86,
			  0xc9, 0x1f, 0xd4, 0x03, 0xdf, 0x10, 0x8e, 0x97,
			  0x59, 0x84, 0x09, 0xc9, 0x5b, 0xda, 0xfd, 0xc5,},
		},
		{/* 32 bytes pt, 256 bits key, nopad */
			32, 32, 51200000, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			  0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0xa0, 0x0f, 0x1e, 0xde, 0x67, 0xc6, 0xf8, 0x03,
			  0x52, 0x6f, 0x2e, 0x3c, 0x4e, 0xa9, 0x29, 0xbc,
			  0x70, 0x5c, 0x82, 0x0e, 0x37, 0x1f, 0x3e, 0x05,
			  0x13, 0x47, 0x0d, 0x66, 0xdc, 0x48, 0x4e, 0xe9,},
		},
		{ 0, 0, 0, 0, {0}, {0}, {0} }
	};

	int32_t i, j, k, n, n_avrg = 1000;
	uint8_t tmp[192];
	sprd_crypto_context_t aes;
	sprd_crypto_err_t err;
	lk_bigtime_t start, elapsed = 0;

	/* encrypt 1024B*/
	for(k = 0; k < 3; k++) {
		for (i = 0; tests[i].pt_len != 0; i++) {
			if (i > 1) {
				n_avrg = 1;
			}
			for (n = 0; n < n_avrg; n++) {
			start = current_time_hires();
			err = sprd_aes_init(SPRD_CRYPTO_AES_ECB, SPRD_CRYPTO_ENC, &aes,
					tests[i].key, NULL, tests[i].key_len,
					NULL, 0);
			for (j = 0; j < (int)(tests[k].msg_len / tests[i].pt_len); j++) {
				err |= sprd_aes_process(&aes, tests[i].pt, tmp, tests[i].pt_len);
			}
			err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, tests[i].padding);
			elapsed += current_time_hires() - start;
			}

			if (err != SPRD_CRYPTO_SUCCESS) {
				SPRD_CRYPTO_LOG_DEBUG("aes_ecb encrypt test[%d] FAILED\n", i);
				return SPRD_CRYPTO_ERR_RESULT;
			} else {
				SPRD_CRYPTO_LOG_ERR("%d aes-%d ecb test time is [%lld]us \n",
						tests[k].msg_len, tests[i].key_len*8, elapsed/n_avrg);
			}
			elapsed = 0;
		}
	}
	return SPRD_CRYPTO_SUCCESS;
}

sprd_crypto_err_t sprd_aes_speed_test_cbc (void) {
	static const struct {
		int32_t key_len;
		int32_t iv_len;
		int32_t pt_len;
		int32_t msg_len;
		int32_t padding;
		const uint8_t key[32] __attribute__ ((aligned (8)));
		const uint8_t iv[16] __attribute__ ((aligned (8)));
		const uint8_t pt[192] __attribute__ ((aligned (8)));
		const uint8_t ct[192] __attribute__ ((aligned (8)));
	} tests[] = {
		{
			16, 16, 32, 1024, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x6f, 0x75, 0x79, 0x7d, 0x05, 0xd8, 0xf4, 0xbf,
			  0x27, 0x80, 0xd8, 0xe4, 0x29, 0x02, 0xa9, 0x8f,
			  0xfd, 0x46, 0xf1, 0x35, 0x03, 0x94, 0x87, 0x98,
			  0x4a, 0x95, 0x6c, 0x94, 0xb1, 0xb0, 0xb1, 0x8d, },
		},
		{
			24, 16, 32, 102400, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x20, 0x87, 0x17, 0x32, 0x9e, 0x30, 0xe5, 0x7e,
			  0x9f, 0x61, 0xe4, 0xea, 0x42, 0x39, 0x30, 0x9d,
			  0xbe, 0x7f, 0xe9, 0x1d, 0x4c, 0x01, 0x7e, 0xeb,
			  0x89, 0xfc, 0x2b, 0x56, 0xc4, 0x7f, 0x64, 0x63, },
		},
		{
			32, 16, 32, 51200000, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			  0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x30, 0x22, 0x50, 0x58, 0x7d, 0x12, 0x12, 0xb8,
			  0xd3, 0x4d, 0x0d, 0x9b, 0x4c, 0xd9, 0x95, 0xcb,
			  0xd2, 0x18, 0xff, 0x44, 0xd6, 0xb1, 0x0a, 0x5a,
			  0xf4, 0x54, 0x98, 0x23, 0xcb, 0xc8, 0xc8, 0xa2, },
		},
		{0, 0, 0, 0, 0, {0}, {0}, {0}, {0}}
	};


	int32_t i, j, k, n, n_avrg = 1000;
	uint8_t tmp[192];
	sprd_crypto_context_t aes;
	sprd_crypto_err_t err;
	lk_bigtime_t start, elapsed = 0;

	/* encrypt */
	for(k = 0; k < 3; k++) {
		for (i = 0; tests[i].pt_len != 0; i++) {
			if (i > 1){
				n_avrg = 1;
			}
			for (n = 0; n < n_avrg; n++) {
				start = current_time_hires();
				err = sprd_aes_init(SPRD_CRYPTO_AES_CBC, SPRD_CRYPTO_ENC, &aes,
						tests[i].key, NULL, tests[i].key_len,
						tests[i].iv, tests[i].iv_len);
				for (j = 0; j < (int)tests[k].msg_len / tests[i].pt_len; j++) {
					err |= sprd_aes_process(&aes, tests[i].pt, tmp, tests[i].pt_len);
				}
				err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
				elapsed += current_time_hires() - start;
			}
			if (err != SPRD_CRYPTO_SUCCESS) {
				SPRD_CRYPTO_LOG_DEBUG("aes_cbc encrypt test[%d] FAILED\n", i);
				return SPRD_CRYPTO_ERR_RESULT;
			} else {
				SPRD_CRYPTO_LOG_ERR("%d aes-%d cbc test time is [%lld] \n",
						tests[k].msg_len, tests[i].key_len*8, elapsed/n_avrg);
			}
			elapsed = 0;
		}
	}

	return SPRD_CRYPTO_SUCCESS;
}

sprd_crypto_err_t sprd_aes_speed_test_ctr (void) {
	static const struct {
			int32_t key_len;
			int32_t iv_len;
			int32_t pt_len;
			int32_t msg_len;
			int32_t padding;
			const uint8_t key[16] __attribute__ ((aligned (8)));
			const uint8_t iv[16] __attribute__ ((aligned (8)));
			const uint8_t pt[32] __attribute__ ((aligned (8)));
			const uint8_t ct[32] __attribute__ ((aligned (8)));
	} tests[] = {
		/* 128-bit key, 32-byte pt */
		{
			16, 16, 32, 1024, SPRD_SYM_NOPAD,
			{	0xAE,0x68,0x52,0xF8,0x12,0x10,0x67,0xCC,
				0x4B,0xF7,0xA5,0x76,0x55,0x77,0xF3,0x9E },
			{	0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01 },//0x00 },
			{	0x53,0x69,0x6E,0x67,0x6C,0x65,0x20,0x62,
				0x6C,0x6F,0x63,0x6B,0x20,0x6D,0x73,0x67,
				0x53,0x69,0x6E,0x67,0x6C,0x65,0x20,0x62,
				0x6C,0x6F,0x63,0x6B,0x20,0x6D,0x73,0x67 },
			{	0xE4,0x09,0x5D,0x4F,0xB7,0xA7,0xB3,0x79,
				0x2D,0x61,0x75,0xA3,0x26,0x13,0x11,0xB8,
				0xE4,0x09,0x5D,0x4F,0xB7,0xA7,0xB3,0x79,
				0x2D,0x61,0x75,0xA3,0x26,0x13,0x11,0xB8 },
		},

		/* 128-bit key, 32-byte pt */
		{
			16, 16, 32, 102400, SPRD_SYM_NOPAD,
			{	0x76,0x91,0xBE,0x03,0x5E,0x50,0x20,0xA8,
				0xAC,0x6E,0x61,0x85,0x29,0xF9,0xA0,0xDC },
			{	0x00,0xE0,0x01,0x7B,0x27,0x77,0x7F,0x3F,
				0x4A,0x17,0x86,0xF0,0x00,0x00,0x00,0x01 },//0x00 },
			{	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
				0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
				0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
				0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F },
			{	0xC1,0xCF,0x48,0xA8,0x9F,0x2F,0xFD,0xD9,
				0xCF,0x46,0x52,0xE9,0xEF,0xDB,0x72,0xD7,
				0x45,0x40,0xA4,0x2B,0xDE,0x6D,0x78,0x36,
				0xD5,0x9A,0x5C,0xEA,0xAE,0xF3,0x10,0x53 },
		},

		/* 128-bit key, 32-byte pt */
		{
			16, 16, 32, 51200000, SPRD_SYM_NOPAD,
			{	0x76,0x91,0xBE,0x03,0x5E,0x50,0x20,0xA8,
				0xAC,0x6E,0x61,0x85,0x29,0xF9,0xA0,0xDC },
			{	0x00,0xE0,0x01,0x7B,0x27,0x77,0x7F,0x3F,
				0x4A,0x17,0x86,0xF0,0x00,0x00,0x00,0x00 },
			{	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
				0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
				0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
				0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,},
			{	0xC1,0xCF,0x48,0xA8,0x9F,0x2F,0xFD,0xD9,
				0xCF,0x46,0x52,0xE9,0xEF,0xDB,0x72,0xD7,
				0x45,0x40,0xA4,0x2B,0xDE,0x6D,0x78,0x36,
				0xD5,0x9A,0x5C,0xEA,0xAE,0xF3,0x10,0x53,},
		},

		{0, 0, 0, 0, 0, {0}, {0}, {0}, {0}}
	};

	int32_t i, j, k, n, n_avrg = 1000;
	uint8_t tmp[36];
	sprd_crypto_context_t aes;
	sprd_crypto_err_t err;
	lk_bigtime_t start, elapsed = 0;

	/* encrypt */
	for (k = 0; k < 3; k++) {
		for (i = 0; tests[i].pt_len != 0; i++) {
			if (i > 1) {
				n_avrg = 1;
			}
			for (n = 0; n < n_avrg; n++) {
				start = current_time_hires();
				err = sprd_aes_init(SPRD_CRYPTO_AES_CTR, SPRD_CRYPTO_ENC, &aes,
						tests[i].key, NULL, tests[i].key_len,
						tests[i].iv, tests[i].iv_len);
				for (j = 0; j < (int)tests[k].msg_len / tests[i].pt_len; j++) {
					err |= sprd_aes_process(&aes, tests[i].pt, tmp, tests[i].pt_len);
				}
				err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
				elapsed += current_time_hires() - start;
			}

			if (err != SPRD_CRYPTO_SUCCESS) {
				SPRD_CRYPTO_LOG_DEBUG("aes_ctr encrypt test[%d] FAILED\n", i);
				return SPRD_CRYPTO_ERR_RESULT;
			} else {
				SPRD_CRYPTO_LOG_ERR("%d aes-%d ctr test time is [%lld] \n",
						tests[k].msg_len, tests[i].key_len*8, elapsed/n_avrg);
			}
			elapsed = 0;
		}
	}

	return SPRD_CRYPTO_SUCCESS;
}

sprd_crypto_err_t sprd_aes_speed_test_huk (void) {
	static const struct {
		uint32_t algo;
		int32_t key_len;
		int32_t iv_len;
		int32_t pt_len;
		int32_t msg_len;
		int32_t padding;
		const uint8_t key[32] __attribute__ ((aligned (8)));
		const uint8_t iv[16] __attribute__ ((aligned (8)));
		const uint8_t pt[192] __attribute__ ((aligned (8)));
		const uint8_t ct[192] __attribute__ ((aligned (8)));
	} tests[] = {
		{
			SPRD_CRYPTO_AES_CBC_HUK,
			16, 16, 32, 1024, SPRD_SYM_NOPAD,
			{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x40, 0x3d, 0x81, 0x5d, 0x71, 0xc2, 0x27, 0xbd,
			  0x1a, 0x23, 0x37, 0x51, 0x23, 0x5c, 0x6f, 0x28,
			  0x3d, 0x14, 0x3d, 0x8d, 0x8f, 0x9e, 0xf0, 0x3b,
			  0xa1, 0x22, 0xf1, 0x28, 0xef, 0x8f, 0x59, 0x69, },
		},
		{
			SPRD_CRYPTO_AES_CBC_HUK,
			24, 16, 32, 102400, SPRD_SYM_NOPAD,
			{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x9f, 0xf6, 0xc2, 0x57, 0x16, 0xfc, 0x68, 0x68,
			  0x24, 0xa9, 0x12, 0xe3, 0xbc, 0xdc, 0x99, 0xce,
			  0x74, 0x3d, 0xc2, 0xb1, 0x74, 0xd5, 0x99, 0xb9,
			  0x98, 0xc8, 0xae, 0xba, 0xf2, 0xff, 0x98, 0xde, },
		},
		{
			SPRD_CRYPTO_AES_CBC_HUK,
			32, 16, 32, 51200000, SPRD_SYM_NOPAD,
			{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x5c, 0xa0, 0x2b, 0xaa, 0x30, 0x00, 0x05, 0x0c,
			  0x75, 0xe8, 0xf5, 0xfa, 0xb0, 0x19, 0xf5, 0xff,
			  0xb3, 0xbc, 0xdc, 0xa2, 0x0e, 0x38, 0xe9, 0xb7,
			  0x36, 0xb1, 0x22, 0x88, 0x48, 0x59, 0x64, 0x0e, },
		},
	};


	uint32_t i, j, k, n, n_avrg = 1000;
	uint8_t tmp[32];
	sprd_crypto_context_t aes;
	sprd_crypto_err_t err;
	lk_bigtime_t start, elapsed = 0;

	/* encrypt */
	for (k = 0; k < 3; k++) {
		for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) {
			if (i > 1){
				n_avrg = 1;
			}
			for (n = 0; n < n_avrg; n++) {
				start = current_time_hires();
				err = sprd_aes_init(tests[i].algo, SPRD_CRYPTO_ENC, &aes,
						NULL, NULL, tests[i].key_len,
						tests[i].iv, tests[i].iv_len);
				if (err != SPRD_CRYPTO_SUCCESS) {
					SPRD_CRYPTO_LOG_DEBUG("aes_cbc encrypt test[%d] init FAILED\n", i);
					return SPRD_CRYPTO_ERR_RESULT;
				}

				for (j = 0; j < (uint32_t)(tests[k].msg_len / tests[i].pt_len); j++) {
					err |= sprd_aes_process(&aes, tests[i].pt, tmp, tests[i].pt_len);
				}
				if (err != SPRD_CRYPTO_SUCCESS) {
					SPRD_CRYPTO_LOG_DEBUG("aes_cbc encrypt test[%d] process FAILED\n", i);
					return SPRD_CRYPTO_ERR_RESULT;
				}

				err = sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
				elapsed += current_time_hires() - start;
			}

			if (err != SPRD_CRYPTO_SUCCESS) {
				SPRD_CRYPTO_LOG_DEBUG("aes_cbc encrypt test[%d] final FAILED\n", i);
				return SPRD_CRYPTO_ERR_RESULT;
			} else {
				SPRD_CRYPTO_LOG_ERR("%d aes-%d huk test time is [%lld] \n",
						tests[k].msg_len, tests[i].key_len*8, elapsed/n_avrg);
			}
			elapsed = 0;
		}
	}

	return SPRD_CRYPTO_SUCCESS;
}

sprd_crypto_err_t sprd_aes_speed_test_xts (void) {
	static const struct {
		int32_t key_len;
		int32_t iv_len;
		int32_t pt_len;
		int32_t msg_len;
		int32_t padding;
		const uint8_t key1[32] __attribute__ ((aligned (8)));
		const uint8_t key2[32] __attribute__ ((aligned (8)));
		const uint8_t iv[16] __attribute__ ((aligned (8)));
		const uint8_t pt[512] __attribute__ ((aligned (8)));
		const uint8_t ct[512] __attribute__ ((aligned (8)));
	} tests[] = {
		/* 32 byte key, 32 byte PTX */
		{
			32, 16, 32, 1024, SPRD_SYM_NOPAD,
			{	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
			{	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
			{	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
			{	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
			{	0x91,0x7c,0xf6,0x9e,0xbd,0x68,0xb2,0xec,
				0x9b,0x9f,0xe9,0xa3,0xea,0xdd,0xa6,0x92,
				0xcd,0x43,0xd2,0xf5,0x95,0x98,0xed,0x85,
				0x8c,0x02,0xc2,0x65,0x2f,0xbf,0x92,0x2e },
		},
		/* 48 byte key, 32 byte PTX */
		{
			48, 16, 32, 102400, SPRD_SYM_NOPAD,
			{	0x30,0x44,0x95,0x80,0x43,0x2F,0x1C,0xAE,
				0x88,0x77,0xCF,0x06,0x8E,0xE8,0x32,0x5F,
				0x32,0x04,0x9C,0xD9,0xC0,0x83,0xCD,0x14 },
			{	0xB2,0xDD,0xD7,0xDC,0xD5,0xC8,0xA9,0xEF,
				0x1D,0xB5,0xD7,0x28,0x9C,0xC5,0xFE,0xDC,
				0xF5,0xE8,0xB0,0x7B,0xAD,0x0F,0xE9,0x97 },
			{	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff },
			{	0xEA,0x00,0xD4,0x2A,0xB3,0x82,0x3C,0x0D,
				0x5C,0x32,0xF2,0xFD,0x90,0xEB,0xAF,0x58,
				0x30,0x51,0x0D,0x97,0xFD,0x62,0x2B,0x37,
				0x0C,0x5B,0x49,0x48,0x69,0x73,0x11,0xD3 },
			{	0xdf,0xf2,0x87,0x01,0x12,0x43,0xa9,0x83,
				0x7b,0xcf,0x40,0xd5,0x90,0xda,0x5c,0xc7,
				0x28,0xcf,0xd2,0xe2,0xd1,0x3f,0x9b,0xf1,
				0x11,0x39,0x46,0x41,0xf1,0x40,0x6d,0x1e },
		},
		/* 64 byte key, 32 byte PTX */
		{
			64, 16, 32, 51200000, SPRD_SYM_NOPAD,
			{	0x27,0x18,0x28,0x18,0x28,0x45,0x90,0x45,
				0x23,0x53,0x60,0x28,0x74,0x71,0x35,0x26,
				0x62,0x49,0x77,0x57,0x24,0x70,0x93,0x69,
				0x99,0x59,0x57,0x49,0x66,0x96,0x76,0x27 },
			{	0x31,0x41,0x59,0x26,0x53,0x58,0x97,0x93,
				0x23,0x84,0x62,0x64,0x33,0x83,0x27,0x95,
				0x02,0x88,0x41,0x97,0x16,0x93,0x99,0x37,
				0x51,0x05,0x82,0x09,0x74,0x94,0x45,0x92 },
			{	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
				0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff },
			{	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
				0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
				0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,
				0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f },
			{	0x1c,0x3b,0x3a,0x10,0x2f,0x77,0x03,0x86,
				0xe4,0x83,0x6c,0x99,0xe3,0x70,0xcf,0x9b,
				0xea,0x00,0x80,0x3f,0x5e,0x48,0x23,0x57,
				0xa4,0xae,0x12,0xd4,0x14,0xa3,0xe6,0x3b },
		},

		{0, 0, 0, 0, 0, {0}, {0}, {0}, {0}, {0}}

	};

	int32_t i, j, k, n, n_avrg;
	uint8_t tmp[512];
	sprd_crypto_context_t aes;
	sprd_crypto_err_t err;
	lk_bigtime_t start, elapsed = 0;

	/* encrypt */
	for (k = 0; k < 3; k++) {
		for (i = 0; tests[i].pt_len != 0; i++) {
			if (i > 1){
				n_avrg = 1;
			}
			for (n = 0; n < n_avrg; n++) {
			start = current_time_hires();
			err = sprd_aes_init(SPRD_CRYPTO_AES_XTS, SPRD_CRYPTO_ENC, &aes,
					tests[i].key1, tests[i].key2, tests[i].key_len/2,
					tests[i].iv, tests[i].iv_len);
			for (j = 0; j < (int)tests[k].msg_len / tests[i].pt_len; j++) {
				err |= sprd_aes_process(&aes, tests[i].pt, tmp, tests[i].pt_len);
			}
			err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
			elapsed += current_time_hires() - start;
			}

			if (err != SPRD_CRYPTO_SUCCESS) {
				SPRD_CRYPTO_LOG_DEBUG("aes_xts encrypt test[%d] FAILED\n", i);
				return SPRD_CRYPTO_ERR_RESULT;
			} else {
				SPRD_CRYPTO_LOG_ERR("%d aes-%d xts test time is [%lld] \n",
						tests[k].msg_len, tests[i].key_len*8, elapsed/n_avrg);
			}
			elapsed = 0;
		}
	}

	return SPRD_CRYPTO_SUCCESS;
}

sprd_crypto_err_t sprd_aes_speed_test (void) {
	sprd_crypto_err_t err = SPRD_CRYPTO_SUCCESS;
	int32_t aes_ecb = 0, aes_cbc = 0, aes_ctr = 0, aes_xts = 0, aes_huk = 0;

	err = sprd_aes_speed_test_ecb();
	if (err != SPRD_CRYPTO_SUCCESS) {
		SPRD_CRYPTO_LOG_ERR("****sprd_aes_speed_test_ecb FAILED!****\n");
		goto failed;
	} else {
		aes_ecb = 1;
	}

	err = sprd_aes_speed_test_cbc();
	if (err != SPRD_CRYPTO_SUCCESS) {
		SPRD_CRYPTO_LOG_ERR("****sprd_aes_speed_test_cbc FAILED!****\n");
		goto failed;
	} else {
		aes_cbc = 1;
	}

	err = sprd_aes_speed_test_ctr();
	if (err != SPRD_CRYPTO_SUCCESS) {
		SPRD_CRYPTO_LOG_ERR("****sprd_aes_speed_test_ctr FAILED!****\n");
		goto failed;
	} else {
		aes_ctr = 1;
	}

	err = sprd_aes_speed_test_xts();
	if (err != SPRD_CRYPTO_SUCCESS) {
		SPRD_CRYPTO_LOG_ERR("****sprd_aes_speed_test_xts FAILED!****\n");
		goto failed;
	} else {
		aes_xts = 1;
	}

	err = sprd_aes_speed_test_huk();
	if (err != SPRD_CRYPTO_SUCCESS) {
		SPRD_CRYPTO_LOG_ERR("****sprd_aes_speed_test_huk FAILED!****\n");
		goto failed;
	} else {
		aes_huk = 1;
	}
failed:
	if (aes_ecb == 1) {
		SPRD_CRYPTO_LOG_WARN("sprd_aes_speed_test_ecb pass!\n");
	}

	if (aes_cbc == 1) {
		SPRD_CRYPTO_LOG_WARN("sprd_aes_speed_test_cbc pass!\n");
	}

	if (aes_ctr == 1) {
		SPRD_CRYPTO_LOG_WARN("sprd_aes_speed_test_ctr pass!\n");
	}

	if (aes_xts == 1) {
		SPRD_CRYPTO_LOG_WARN("sprd_aes_speed_test_xts pass!\n");
	}

	if (aes_huk == 1) {
		SPRD_CRYPTO_LOG_WARN("sprd_aes_speed_test_huk pass!\n");
	}

	return err;
}
#endif

sprd_crypto_err_t sprd_aes_test_ecb (void) {
	static const struct {
		uint32_t key_len;
		uint32_t pt_len;
		int32_t padding;
		const uint8_t key[32] __attribute__ ((aligned (8)));
		const uint8_t pt[192] __attribute__ ((aligned (8)));
		const uint8_t ct[192] __attribute__ ((aligned (8)));
	} tests[] = {
		{/* 32 bytes pt, 128 bits key, nopad */
			16, 32, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0xdb, 0x7c, 0xe6, 0x7a, 0xf1, 0x3d, 0xe5, 0x7a,
			  0x95, 0xd9, 0x22, 0xe5, 0x32, 0x5a, 0xbf, 0x13,
			  0x77, 0x10, 0x98, 0xa6, 0xb7, 0x8c, 0xb4, 0x5c,
			  0x02, 0x9c, 0xf1, 0xc0, 0xdd, 0xee, 0x0f, 0x1b} ,
		},
		{/* 32 bytes pt, 192 bits key, nopad */
			24, 32, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x31, 0x6c, 0xe2, 0x04, 0x25, 0x64, 0x03, 0x57,
			  0x66, 0x45, 0x4d, 0xdf, 0x7c, 0x1a, 0x50, 0x86,
			  0xc9, 0x1f, 0xd4, 0x03, 0xdf, 0x10, 0x8e, 0x97,
			  0x59, 0x84, 0x09, 0xc9, 0x5b, 0xda, 0xfd, 0xc5,},
		},
		{/* 32 bytes pt, 256 bits key, nopad */
			32, 32,	SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			  0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0xa0, 0x0f, 0x1e, 0xde, 0x67, 0xc6, 0xf8, 0x03,
			  0x52, 0x6f, 0x2e, 0x3c, 0x4e, 0xa9, 0x29, 0xbc,
			  0x70, 0x5c, 0x82, 0x0e, 0x37, 0x1f, 0x3e, 0x05,
			  0x13, 0x47, 0x0d, 0x66, 0xdc, 0x48, 0x4e, 0xe9,},
		},
		{/*64 bytes pt, 128 bits key, nopad */
			16,
			64,
			SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			  0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, },
			{ 0xdb, 0x7c, 0xe6, 0x7a, 0xf1, 0x3d, 0xe5, 0x7a,
			  0x95, 0xd9, 0x22, 0xe5, 0x32, 0x5a, 0xbf, 0x13,
			  0x77, 0x10, 0x98, 0xa6, 0xb7, 0x8c, 0xb4, 0x5c,
			  0x02, 0x9c, 0xf1, 0xc0, 0xdd, 0xee, 0x0f, 0x1b,
			  0xcc, 0x0d, 0xd1, 0x5b, 0x23, 0xe6, 0x82, 0x9e,
			  0x05, 0xf6, 0xe4, 0x17, 0xf4, 0x64, 0xb6, 0x99,
			  0xa7, 0xad, 0xee, 0xae, 0xcc, 0xa5, 0x48, 0x89,
			  0xb8, 0x62, 0x1b, 0xec, 0x18, 0x52, 0x70, 0x44, },
		},
		{/* 128 bytes pt, 128 bits key, nopad */
			16,
			128,
			SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			  0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			  0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
			  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			  0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
			  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
			  0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
			  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
			  0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, },
			{ 0xdb, 0x7c, 0xe6, 0x7a, 0xf1, 0x3d, 0xe5, 0x7a,
			  0x95, 0xd9, 0x22, 0xe5, 0x32, 0x5a, 0xbf, 0x13,
			  0x77, 0x10, 0x98, 0xa6, 0xb7, 0x8c, 0xb4, 0x5c,
			  0x02, 0x9c, 0xf1, 0xc0, 0xdd, 0xee, 0x0f, 0x1b,
			  0xcc, 0x0d, 0xd1, 0x5b, 0x23, 0xe6, 0x82, 0x9e,
			  0x05, 0xf6, 0xe4, 0x17, 0xf4, 0x64, 0xb6, 0x99,
			  0xa7, 0xad, 0xee, 0xae, 0xcc, 0xa5, 0x48, 0x89,
			  0xb8, 0x62, 0x1b, 0xec, 0x18, 0x52, 0x70, 0x44,
			  0x85, 0x94, 0x69, 0xc0, 0x77, 0x43, 0xc7, 0xe4,
			  0x5b, 0x31, 0x8d, 0x15, 0x1d, 0x3d, 0x87, 0xe9,
			  0xb0, 0x51, 0x59, 0xc3, 0x64, 0x39, 0x27, 0xe5,
			  0x45, 0x47, 0xe8, 0xa1, 0x47, 0x21, 0xd1, 0xeb,
			  0x26, 0x02, 0xf2, 0xf0, 0xa5, 0x8c, 0xfb, 0xd1,
			  0xcd, 0x1a, 0x16, 0xcf, 0xd9, 0x8b, 0xee, 0x32,
			  0x1e, 0x93, 0x9c, 0x68, 0x45, 0xaf, 0xfd, 0x5f,
			  0x9a, 0x56, 0xc1, 0x5f, 0xda, 0x2e, 0x55, 0x2f, },
		},
		{/* 192 bytes pt, 128 bits key, nopad */
			16,
			192,
			SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			  0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			  0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
			  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			  0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
			  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
			  0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
			  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
			  0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
			  0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
			  0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
			  0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
			  0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
			  0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
			  0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
			  0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
			  0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, },
			{ 0xdb, 0x7c, 0xe6, 0x7a, 0xf1, 0x3d, 0xe5, 0x7a,
			  0x95, 0xd9, 0x22, 0xe5, 0x32, 0x5a, 0xbf, 0x13,
			  0x77, 0x10, 0x98, 0xa6, 0xb7, 0x8c, 0xb4, 0x5c,
			  0x02, 0x9c, 0xf1, 0xc0, 0xdd, 0xee, 0x0f, 0x1b,
			  0xcc, 0x0d, 0xd1, 0x5b, 0x23, 0xe6, 0x82, 0x9e,
			  0x05, 0xf6, 0xe4, 0x17, 0xf4, 0x64, 0xb6, 0x99,
			  0xa7, 0xad, 0xee, 0xae, 0xcc, 0xa5, 0x48, 0x89,
			  0xb8, 0x62, 0x1b, 0xec, 0x18, 0x52, 0x70, 0x44,
			  0x85, 0x94, 0x69, 0xc0, 0x77, 0x43, 0xc7, 0xe4,
			  0x5b, 0x31, 0x8d, 0x15, 0x1d, 0x3d, 0x87, 0xe9,
			  0xb0, 0x51, 0x59, 0xc3, 0x64, 0x39, 0x27, 0xe5,
			  0x45, 0x47, 0xe8, 0xa1, 0x47, 0x21, 0xd1, 0xeb,
			  0x26, 0x02, 0xf2, 0xf0, 0xa5, 0x8c, 0xfb, 0xd1,
			  0xcd, 0x1a, 0x16, 0xcf, 0xd9, 0x8b, 0xee, 0x32,
			  0x1e, 0x93, 0x9c, 0x68, 0x45, 0xaf, 0xfd, 0x5f,
			  0x9a, 0x56, 0xc1, 0x5f, 0xda, 0x2e, 0x55, 0x2f,
			  0x25, 0x4b, 0x1c, 0x41, 0x80, 0x0c, 0x8d, 0x3d,
			  0xf5, 0xfb, 0x55, 0x37, 0xbf, 0x3a, 0x96, 0x1f,
			  0xfd, 0x3e, 0x50, 0x61, 0x75, 0xb1, 0xf8, 0xbb,
			  0xdb, 0x29, 0x24, 0x91, 0x84, 0x14, 0x87, 0xfd,
			  0x8a, 0xef, 0x4b, 0x6f, 0x9c, 0x4c, 0x0a, 0xd0,
			  0x5b, 0xba, 0xa8, 0xbb, 0xc4, 0x3c, 0x8d, 0x7f,
			  0x4c, 0x08, 0xb4, 0x7a, 0xbf, 0x0c, 0x93, 0x9f,
			  0x5d, 0x6f, 0xf7, 0xe2, 0xa3, 0x5b, 0x16, 0xa0, },
		},

		{ 0, 0, 0, {0}, {0}, {0} }
	};

	int32_t i;
	uint8_t tmp[192];
	sprd_crypto_context_t aes;
	sprd_crypto_err_t err;

	/* encrypt */
	for (i = 0; tests[i].pt_len != 0; i++) {
		err = sprd_aes_init(SPRD_CRYPTO_AES_ECB, SPRD_CRYPTO_ENC, &aes,
				tests[i].key, NULL, tests[i].key_len,
				NULL, 0);
		err |= sprd_aes_process(&aes, tests[i].pt, tmp, tests[i].pt_len);
		err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, tests[i].padding);
		if (err != SPRD_CRYPTO_SUCCESS
			|| sprd_pal_memcmp(tmp, tests[i].ct, tests[i].pt_len) != 0) {
			SPRD_CRYPTO_LOG_DEBUG("aes_ecb encrypt test[%d] FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}
	}

	/* decrypt */
	for (i = 0; tests[i].pt_len != 0; i++) {
		err = sprd_aes_init(SPRD_CRYPTO_AES_ECB, SPRD_CRYPTO_DEC, &aes,
				tests[i].key, NULL, tests[i].key_len,
				NULL, 0);
		err |= sprd_aes_process(&aes, tests[i].ct, tmp, tests[i].pt_len);
		err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, tests[i].padding);
		if (err != SPRD_CRYPTO_SUCCESS
			|| sprd_pal_memcmp(tmp, tests[i].pt, tests[i].pt_len) != 0) {
			SPRD_CRYPTO_LOG_DEBUG("aes_ecb decrypt test[%d] FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}
	}

	/* special 0:16+48 */
	err = sprd_aes_init(SPRD_CRYPTO_AES_ECB, SPRD_CRYPTO_ENC, &aes,
			tests[3].key, NULL, tests[3].key_len,
			NULL, 0);
	err |= sprd_aes_process(&aes, tests[3].pt, tmp, 16);
	err |= sprd_aes_process(&aes, tests[3].pt + 16, tmp + 16, 48);
	err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, tests[3].padding);
	if (err != SPRD_CRYPTO_SUCCESS
		|| sprd_pal_memcmp(tmp, tests[3].ct, tests[3].pt_len) != 0) {
		SPRD_CRYPTO_LOG_DEBUG("aes_ecb special 0 FAILED\n");
		return SPRD_CRYPTO_ERR_RESULT;
	}

	/* special 1:16+64+48 */
	err = sprd_aes_init(SPRD_CRYPTO_AES_ECB, SPRD_CRYPTO_ENC, &aes,
			tests[4].key, NULL, tests[4].key_len,
			NULL, 0);
	err |= sprd_aes_process(&aes, tests[4].pt, tmp, 16);
	err |= sprd_aes_process(&aes, tests[4].pt + 16, tmp + 16, 64);
	err |= sprd_aes_process(&aes, tests[4].pt + 80, tmp + 80, 48);
	err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, tests[4].padding);
	if (err != SPRD_CRYPTO_SUCCESS
		|| sprd_pal_memcmp(tmp, tests[4].ct, tests[4].pt_len) != 0) {
		SPRD_CRYPTO_LOG_DEBUG("aes_ecb special 1 FAILED\n");
		return SPRD_CRYPTO_ERR_RESULT;
	}

	/* special 2:16+80+32 */
	err = sprd_aes_init(SPRD_CRYPTO_AES_ECB, SPRD_CRYPTO_ENC, &aes,
			tests[4].key, NULL, tests[4].key_len,
			NULL, 0);
	err |= sprd_aes_process(&aes, tests[4].pt, tmp, 16);
	err |= sprd_aes_process(&aes, tests[4].pt + 16, tmp + 16, 80);
	err |= sprd_aes_process(&aes, tests[4].pt + 96, tmp + 96, 32);
	err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, tests[4].padding);
	if (err != SPRD_CRYPTO_SUCCESS
		|| sprd_pal_memcmp(tmp, tests[4].ct, tests[4].pt_len) != 0) {
		SPRD_CRYPTO_LOG_DEBUG("aes_ecb special 2 FAILED\n");
		return SPRD_CRYPTO_ERR_RESULT;
	}

	/* special 3:16+144+32 */
	err = sprd_aes_init(SPRD_CRYPTO_AES_ECB, SPRD_CRYPTO_ENC, &aes,
			tests[5].key, NULL, tests[5].key_len,
			NULL, 0);
	err |= sprd_aes_process(&aes, tests[5].pt, tmp, 16);
	err |= sprd_aes_process(&aes, tests[5].pt + 16, tmp + 16, 144);
	err |= sprd_aes_process(&aes, tests[5].pt + 160, tmp + 160, 32);
	err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, tests[5].padding);
	if (err != SPRD_CRYPTO_SUCCESS
		|| sprd_pal_memcmp(tmp, tests[5].ct, tests[5].pt_len) != 0) {
		SPRD_CRYPTO_LOG_DEBUG("aes_ecb special 3 FAILED\n");
		return SPRD_CRYPTO_ERR_RESULT;
	}

	return SPRD_CRYPTO_SUCCESS;
}

sprd_crypto_err_t sprd_aes_test_cbc (void) {
	static const struct {
		int32_t key_len;
		int32_t iv_len;
		int32_t pt_len;
		int32_t padding;
		const uint8_t key[32];// __attribute__ ((aligned (8)));
		const uint8_t iv[16];// __attribute__ ((aligned (8)));
		const uint8_t pt[192];// __attribute__ ((aligned (8)));
		const uint8_t ct[192];// __attribute__ ((aligned (8)));
	} tests[] = {
		{
			16, 16, 32, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x6f, 0x75, 0x79, 0x7d, 0x05, 0xd8, 0xf4, 0xbf,
			  0x27, 0x80, 0xd8, 0xe4, 0x29, 0x02, 0xa9, 0x8f,
			  0xfd, 0x46, 0xf1, 0x35, 0x03, 0x94, 0x87, 0x98,
			  0x4a, 0x95, 0x6c, 0x94, 0xb1, 0xb0, 0xb1, 0x8d, },
		},
		{
			24, 16, 32, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x20, 0x87, 0x17, 0x32, 0x9e, 0x30, 0xe5, 0x7e,
			  0x9f, 0x61, 0xe4, 0xea, 0x42, 0x39, 0x30, 0x9d,
			  0xbe, 0x7f, 0xe9, 0x1d, 0x4c, 0x01, 0x7e, 0xeb,
			  0x89, 0xfc, 0x2b, 0x56, 0xc4, 0x7f, 0x64, 0x63, },
		},
		{
			32, 16, 32, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			  0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x30, 0x22, 0x50, 0x58, 0x7d, 0x12, 0x12, 0xb8,
			  0xd3, 0x4d, 0x0d, 0x9b, 0x4c, 0xd9, 0x95, 0xcb,
			  0xd2, 0x18, 0xff, 0x44, 0xd6, 0xb1, 0x0a, 0x5a,
			  0xf4, 0x54, 0x98, 0x23, 0xcb, 0xc8, 0xc8, 0xa2, },
		},

		{
			32, 16, 192, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			  0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
			  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
			  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
			  0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
			  0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
			  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57,
			  0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
			  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
			  0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
			  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
			  0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
			  0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
			  0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
			  0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
			  0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
			  0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
			  0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
			  0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7,
			  0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, },
			{ 0x30, 0x22, 0x50, 0x58, 0x7d, 0x12, 0x12, 0xb8,
			  0xd3, 0x4d, 0x0d, 0x9b, 0x4c, 0xd9, 0x95, 0xcb,
			  0xd2, 0x18, 0xff, 0x44, 0xd6, 0xb1, 0x0a, 0x5a,
			  0xf4, 0x54, 0x98, 0x23, 0xcb, 0xc8, 0xc8, 0xa2,
			  0x4d, 0x42, 0x5f, 0x66, 0x36, 0xf6, 0x50, 0x82,
			  0xdd, 0xf3, 0x49, 0x80, 0x5d, 0x71, 0x03, 0xd3,
			  0x1b, 0x65, 0xfd, 0xb1, 0x6a, 0xcd, 0x8c, 0xc4,
			  0x8c, 0x20, 0xa7, 0x26, 0x77, 0x06, 0x4e, 0xc5,
			  0x94, 0x62, 0xae, 0xe8, 0xeb, 0x1d, 0x9c, 0xb1,
			  0xa4, 0xb1, 0x09, 0x71, 0xdd, 0xcd, 0x12, 0xd1,
			  0x1c, 0xc6, 0x10, 0x80, 0xf4, 0x2e, 0x3c, 0xab,
			  0x06, 0x78, 0xeb, 0x33, 0xe2, 0xe5, 0xdf, 0xe7,
			  0x30, 0x29, 0x24, 0x7e, 0x8e, 0x03, 0x65, 0xf9,
			  0x9f, 0xf7, 0x4f, 0x28, 0xb5, 0x7a, 0x21, 0xac,
			  0x99, 0x02, 0xfd, 0x9f, 0xdf, 0xab, 0x4c, 0xc3,
			  0xca, 0x84, 0xe0, 0x65, 0x5a, 0xd2, 0x8e, 0xd4,
			  0x34, 0x57, 0x83, 0xd0, 0x13, 0x1f, 0xdf, 0x17,
			  0xe2, 0x90, 0xef, 0xdb, 0xbc, 0x4e, 0xfb, 0x4d,
			  0x4c, 0x6c, 0x09, 0xea, 0x4d, 0x40, 0xdb, 0x2c,
			  0xea, 0x5e, 0xaa, 0x65, 0x80, 0x66, 0x8e, 0x61,
			  0x01, 0x07, 0x3a, 0x35, 0x0d, 0xea, 0x6a, 0x20,
			  0xe7, 0xd4, 0x3a, 0xe2, 0x9c, 0xb2, 0x2b, 0xc4,
			  0xe0, 0x34, 0xd0, 0x8b, 0x6c, 0xf9, 0x0d, 0xb9,
			  0x1b, 0x06, 0x48, 0xef, 0x8d, 0x50, 0xed, 0xfc, },
		},

		{0, 0, 0, 0, {0}, {0}, {0}, {0}}
	};


	int32_t i = 0;
	uint8_t tmp[192] = {0};
	uint32_t len_temp;
	sprd_crypto_context_t aes;
	sprd_crypto_err_t err;

	SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt starts.\n");
	/* encrypt */
	for (i = 0; tests[i].pt_len != 0; i++) {
		err = sprd_aes_init(SPRD_CRYPTO_AES_CBC, SPRD_CRYPTO_ENC, &aes,
				tests[i].key, NULL, tests[i].key_len,
				tests[i].iv, tests[i].iv_len);
		if (err != SPRD_CRYPTO_SUCCESS) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt init[%d] FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}
		err = sprd_aes_process(&aes, tests[i].pt, tmp, tests[i].pt_len);
		hexdump_sprd("1tmp:", tmp, tests[i].pt_len);
		if (err != SPRD_CRYPTO_SUCCESS) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt update[%d] FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}
		hexdump_sprd("2tmp:", tmp, tests[i].pt_len);
		err = sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
		if (err != SPRD_CRYPTO_SUCCESS
			|| sprd_pal_memcmp(tmp, tests[i].ct, tests[i].pt_len) != 0) {
			hexdump_sprd("3tmp:", tmp, tests[i].pt_len);
			SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt final[%d] FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}
	}
	SPRD_CRYPTO_LOG_ERR("aes_cbc decypt starts.\n");

	/* decrypt */
	for (i = 0; tests[i].pt_len != 0; i++) {
		err = sprd_aes_init(SPRD_CRYPTO_AES_CBC, SPRD_CRYPTO_DEC, &aes,
				tests[i].key, NULL, tests[i].key_len,
				tests[i].iv, tests[i].iv_len);
		err |= sprd_aes_process(&aes, tests[i].ct, tmp, tests[i].pt_len);
		err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
		if (err != SPRD_CRYPTO_SUCCESS
			|| sprd_pal_memcmp(tmp, tests[i].pt, tests[i].pt_len) != 0) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc decrypt test[%d] FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}
	}
	SPRD_CRYPTO_LOG_ERR("aes_cbc test success.\n");

	/* special case0 */
	len_temp = 128;
	err = sprd_aes_init(SPRD_CRYPTO_AES_CBC, SPRD_CRYPTO_ENC, &aes,
			tests[3].key, NULL, tests[3].key_len,
			tests[3].iv, tests[3].iv_len);
	err |= sprd_aes_process(&aes, tests[3].pt, tmp, 16);
	err |= sprd_aes_process(&aes, tests[3].pt+16, tmp+16, 16);
	err |= sprd_aes_process(&aes, tests[3].pt+32, tmp+32, 32);
	err |= sprd_aes_final(&aes, tests[3].pt+64, 128, tmp+64, &len_temp, SPRD_SYM_NOPAD);
	if (err != SPRD_CRYPTO_SUCCESS
		|| sprd_pal_memcmp(tmp, tests[3].ct, tests[3].pt_len) != 0) {
		SPRD_CRYPTO_LOG_ERR("aes_cbc special 0 FAILED\n");
		return SPRD_CRYPTO_ERR_RESULT;
	}
	SPRD_CRYPTO_LOG_ERR("aes_cbc test success.\n");

	return SPRD_CRYPTO_SUCCESS;
}

sprd_crypto_err_t sprd_aes_test_ctr (void) {
	static const struct {
			int32_t key_len;
			int32_t iv_len;
			int32_t pt_len;
			int32_t padding;
			const uint8_t key[32] __attribute__ ((aligned (8)));
			const uint8_t iv[16] __attribute__ ((aligned (8)));
			const uint8_t pt[36] __attribute__ ((aligned (8)));
			const uint8_t ct[36] __attribute__ ((aligned (8)));
	} tests[] = {
		/* 128-bit key, 16-byte pt */
		{
			16, 16, 16, SPRD_SYM_NOPAD,
			{0xAE,0x68,0x52,0xF8,0x12,0x10,0x67,0xCC,0x4B,0xF7,0xA5,0x76,0x55,0x77,0xF3,0x9E },
			{0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01 },//0x00 },
			{0x53,0x69,0x6E,0x67,0x6C,0x65,0x20,0x62,0x6C,0x6F,0x63,0x6B,0x20,0x6D,0x73,0x67 },
			{0xE4,0x09,0x5D,0x4F,0xB7,0xA7,0xB3,0x79,0x2D,0x61,0x75,0xA3,0x26,0x13,0x11,0xB8 },
		},

		/* 128-bit key, 32-byte pt */
		{
			16, 16, 32, SPRD_SYM_NOPAD,
			{0x76,0x91,0xBE,0x03,0x5E,0x50,0x20,0xA8,0xAC,0x6E,0x61,0x85,0x29,0xF9,0xA0,0xDC },
			{0x00,0xE0,0x01,0x7B,0x27,0x77,0x7F,0x3F,0x4A,0x17,0x86,0xF0,0x00,0x00,0x00,0x01 },//0x00 },
			{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
			 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F },
			{0xC1,0xCF,0x48,0xA8,0x9F,0x2F,0xFD,0xD9,0xCF,0x46,0x52,0xE9,0xEF,0xDB,0x72,0xD7,
			 0x45,0x40,0xA4,0x2B,0xDE,0x6D,0x78,0x36,0xD5,0x9A,0x5C,0xEA,0xAE,0xF3,0x10,0x53 },
		},

		/* 128-bit key, 36-byte pt */
		/*{
			16, 16, 36, SPRD_SYM_NOPAD,
			{0x76,0x91,0xBE,0x03,0x5E,0x50,0x20,0xA8,0xAC,0x6E,0x61,0x85,0x29,0xF9,0xA0,0xDC },
			{0x00,0xE0,0x01,0x7B,0x27,0x77,0x7F,0x3F,0x4A,0x17,0x86,0xF0,0x00,0x00,0x00,0x00 },
			{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
			 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
			 0x20,0x21,0x22,0x23},
			{0xC1,0xCF,0x48,0xA8,0x9F,0x2F,0xFD,0xD9,0xCF,0x46,0x52,0xE9,0xEF,0xDB,0x72,0xD7,
			 0x45,0x40,0xA4,0x2B,0xDE,0x6D,0x78,0x36,0xD5,0x9A,0x5C,0xEA,0xAE,0xF3,0x10,0x53,
			 0x25,0xB2,0x07,0x2F },
		},*/

		{0, 0, 0, 0, {0}, {0}, {0}, {0}}
	};

	int32_t i;
	uint8_t tmp[36];
	sprd_crypto_context_t aes;
	sprd_crypto_err_t err;

	/* encrypt */
	for (i = 0; tests[i].pt_len != 0; i++) {
		err = sprd_aes_init(SPRD_CRYPTO_AES_CTR, SPRD_CRYPTO_ENC, &aes,
				tests[i].key, NULL, tests[i].key_len,
				tests[i].iv, tests[i].iv_len);
		err |= sprd_aes_process(&aes, tests[i].pt, tmp, tests[i].pt_len);
		err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
		if (err != SPRD_CRYPTO_SUCCESS
			|| sprd_pal_memcmp(tmp, tests[i].ct, tests[i].pt_len) != 0) {
			SPRD_CRYPTO_LOG_DEBUG("aes_ctr encrypt test[%d] FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}
	}

	/* decrypt */
	for (i = 0; tests[i].pt_len != 0; i++) {
		err = sprd_aes_init(SPRD_CRYPTO_AES_CTR, SPRD_CRYPTO_DEC, &aes,
				tests[i].key, NULL, tests[i].key_len,
				tests[i].iv, tests[i].iv_len);
		err |= sprd_aes_process(&aes, tests[i].ct, tmp, tests[i].pt_len);
		err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
		if (err != SPRD_CRYPTO_SUCCESS
			|| sprd_pal_memcmp(tmp, tests[i].pt, tests[i].pt_len) != 0) {
			SPRD_CRYPTO_LOG_DEBUG("aes_ctr encrypt test[%d] FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}
	}

	/* special 0 */
	err = sprd_aes_init(SPRD_CRYPTO_AES_CTR, SPRD_CRYPTO_ENC, &aes,
			tests[1].key, NULL, tests[1].key_len,
			tests[1].iv, tests[1].iv_len);
	err |= sprd_aes_process(&aes, tests[1].pt, tmp, 16);
	err |= sprd_aes_process(&aes, tests[1].pt+16, tmp+16, 16);
	err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
	if (err != SPRD_CRYPTO_SUCCESS
		|| sprd_pal_memcmp(tmp, tests[1].ct, tests[1].pt_len) != 0) {
		SPRD_CRYPTO_LOG_DEBUG("aes_ctr special 0 FAILED\n");
		return SPRD_CRYPTO_ERR_RESULT;
	}

	return SPRD_CRYPTO_SUCCESS;
}

sprd_crypto_err_t sprd_aes_test_ctr_hdcp (void) {
	static  struct {
			int32_t key_len;
			int32_t iv_len;
			int32_t pt_len;
			int32_t padding;
			uint8_t key[32] __attribute__ ((aligned (8)));
			const uint8_t iv[16] __attribute__ ((aligned (8)));
			const uint8_t pt[36] __attribute__ ((aligned (8)));
			const uint8_t ct[36] __attribute__ ((aligned (8)));
	} tests[] = {
		/* 128-bit key, 16-byte pt */
		{
			16, 16, 16, SPRD_SYM_NOPAD,
			{0xAE,0x68,0x52,0xF8,0x12,0x10,0x67,0xCC,0x4B,0xF7,0xA5,0x76,0x55,0x77,0xF3,0x9E },
			{0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01 },
			{0x53,0x69,0x6E,0x67,0x6C,0x65,0x20,0x62,0x6C,0x6F,0x63,0x6B,0x20,0x6D,0x73,0x67 },
			{0xE4,0x09,0x5D,0x4F,0xB7,0xA7,0xB3,0x79,0x2D,0x61,0x75,0xA3,0x26,0x13,0x11,0xB8 },
		},

		/* 128-bit key, 32-byte pt */
		{
			16, 16, 32, SPRD_SYM_NOPAD,
			{0x76,0x91,0xBE,0x03,0x5E,0x50,0x20,0xA8,0xAC,0x6E,0x61,0x85,0x29,0xF9,0xA0,0xDC },
			{0x00,0xE0,0x01,0x7B,0x27,0x77,0x7F,0x3F,0x4A,0x17,0x86,0xF0,0x00,0x00,0x00,0x01 },
			{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
			 0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F },
			{0xC1,0xCF,0x48,0xA8,0x9F,0x2F,0xFD,0xD9,0xCF,0x46,0x52,0xE9,0xEF,0xDB,0x72,0xD7,
			 0x45,0x40,0xA4,0x2B,0xDE,0x6D,0x78,0x36,0xD5,0x9A,0x5C,0xEA,0xAE,0xF3,0x10,0x53 },
		},
	};

  int i;
	uint8_t tmp[36];
	sprd_crypto_context_t aes;
	sprd_crypto_err_t err;
	uint8_t xor_data[16] = {0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
                            0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11};
	/* encrypt */
		for (i = 0; i<16; i++) {
			tests[0].key[i] = tests[1].key[i] ^ xor_data[i];
		}
		err = sprd_aes_init(SPRD_CRYPTO_AES_CTR_HDCP, SPRD_CRYPTO_ENC, &aes,
				tests[0].key, NULL, tests[1].key_len,
				tests[1].iv, tests[1].iv_len);
		err |= sprd_aes_process(&aes, tests[1].pt, tmp, tests[1].pt_len);
		err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
		if (err != SPRD_CRYPTO_SUCCESS
			|| sprd_pal_memcmp(tmp, tests[1].ct, tests[1].pt_len) != 0) {
			SPRD_CRYPTO_LOG_DEBUG("aes_ctr hdcp encrypt test FAILED\n");
			return SPRD_CRYPTO_ERR_RESULT;
		}

	return SPRD_CRYPTO_SUCCESS;
}

#define CONST64(n) n ## ULL

sprd_crypto_err_t sprd_aes_test_xts (void) {
	static const struct {
		int32_t key_len;
		int32_t iv_len;
		int32_t pt_len;
		int32_t padding;
		const uint8_t key1[32] __attribute__ ((aligned (8)));
		const uint8_t key2[32] __attribute__ ((aligned (8)));
		const uint8_t iv[16] __attribute__ ((aligned (8)));
		const uint8_t pt[512] __attribute__ ((aligned (8)));
		const uint8_t ct[512] __attribute__ ((aligned (8)));
	} tests[] = {
		/* 32 byte key, 32 byte PTX */
		{
			32, 16,	32, SPRD_SYM_NOPAD,
			{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
			{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
			{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
			{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
			{ 0x91,0x7c,0xf6,0x9e,0xbd,0x68,0xb2,0xec,0x9b,0x9f,0xe9,0xa3,0xea,0xdd,0xa6,0x92,
			  0xcd,0x43,0xd2,0xf5,0x95,0x98,0xed,0x85,0x8c,0x02,0xc2,0x65,0x2f,0xbf,0x92,0x2e },
		},

		/* 32 byte key, 32 byte PTX */
		{
			32, 16, 32, SPRD_SYM_NOPAD,
			{ 0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11,0x11 },
			{ 0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22,0x22 },
			{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x33,0x33,0x33,0x33},
			{ 0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
			  0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44 },
			{ 0xc4,0x54,0x18,0x5e,0x6a,0x16,0x93,0x6e,0x39,0x33,0x40,0x38,0xac,0xef,0x83,0x8b,
			  0xfb,0x18,0x6f,0xff,0x74,0x80,0xad,0xc4,0x28,0x93,0x82,0xec,0xd6,0xd3,0x94,0xf0 },
		},

		/* 32 byte key, 32 byte PTX */
		{
			32, 16, 32, SPRD_SYM_NOPAD,
			{ 0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,0xf6,0xf5,0xf4,0xf3,0xf2,0xf1,0xf0 },
			{ 0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb8,0xb7,0xb6,0xb5,0xb4,0xb3,0xb2,0xb1,0xb0 },
			{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x12,0x34,0x56,0x78,0x9a },
			{ 0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,
			  0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44,0x44 },
			{ 0xb0,0x1f,0x86,0xf8,0xed,0xc1,0x86,0x37,0x06,0xfa,0x8a,0x42,0x53,0xe3,0x4f,0x28,
			  0xaf,0x31,0x9d,0xe3,0x83,0x34,0x87,0x0f,0x4d,0xd1,0xf9,0x4c,0xbe,0x98,0x32,0xf1 },
		},

		/* 32 byte key, 512 byte PTX  */
		{
			32, 16, 512, SPRD_SYM_NOPAD,
			{ 0x27,0x18,0x28,0x18,0x28,0x45,0x90,0x45,0x23,0x53,0x60,0x28,0x74,0x71,0x35,0x26 },
			{ 0x31,0x41,0x59,0x26,0x53,0x58,0x97,0x93,0x23,0x84,0x62,0x64,0x33,0x83,0x27,0x95 },
			{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
			{ 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
			  0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
			  0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
			  0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
			  0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
			  0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
			  0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
			  0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
			  0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
			  0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
			  0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
			  0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
			  0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
			  0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
			  0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
			  0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,
			  0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
			  0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
			  0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
			  0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
			  0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
			  0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
			  0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
			  0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
			  0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
			  0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
			  0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
			  0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
			  0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
			  0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
			  0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
			  0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff, },
			{ 0x27,0xa7,0x47,0x9b,0xef,0xa1,0xd4,0x76,0x48,0x9f,0x30,0x8c,0xd4,0xcf,0xa6,0xe2,
			  0xa9,0x6e,0x4b,0xbe,0x32,0x08,0xff,0x25,0x28,0x7d,0xd3,0x81,0x96,0x16,0xe8,0x9c,
			  0xc7,0x8c,0xf7,0xf5,0xe5,0x43,0x44,0x5f,0x83,0x33,0xd8,0xfa,0x7f,0x56,0x00,0x00,
			  0x05,0x27,0x9f,0xa5,0xd8,0xb5,0xe4,0xad,0x40,0xe7,0x36,0xdd,0xb4,0xd3,0x54,0x12,
			  0x32,0x80,0x63,0xfd,0x2a,0xab,0x53,0xe5,0xea,0x1e,0x0a,0x9f,0x33,0x25,0x00,0xa5,
			  0xdf,0x94,0x87,0xd0,0x7a,0x5c,0x92,0xcc,0x51,0x2c,0x88,0x66,0xc7,0xe8,0x60,0xce,
			  0x93,0xfd,0xf1,0x66,0xa2,0x49,0x12,0xb4,0x22,0x97,0x61,0x46,0xae,0x20,0xce,0x84,
			  0x6b,0xb7,0xdc,0x9b,0xa9,0x4a,0x76,0x7a,0xae,0xf2,0x0c,0x0d,0x61,0xad,0x02,0x65,
			  0x5e,0xa9,0x2d,0xc4,0xc4,0xe4,0x1a,0x89,0x52,0xc6,0x51,0xd3,0x31,0x74,0xbe,0x51,
			  0xa1,0x0c,0x42,0x11,0x10,0xe6,0xd8,0x15,0x88,0xed,0xe8,0x21,0x03,0xa2,0x52,0xd8,
			  0xa7,0x50,0xe8,0x76,0x8d,0xef,0xff,0xed,0x91,0x22,0x81,0x0a,0xae,0xb9,0x9f,0x91,
			  0x72,0xaf,0x82,0xb6,0x04,0xdc,0x4b,0x8e,0x51,0xbc,0xb0,0x82,0x35,0xa6,0xf4,0x34,
			  0x13,0x32,0xe4,0xca,0x60,0x48,0x2a,0x4b,0xa1,0xa0,0x3b,0x3e,0x65,0x00,0x8f,0xc5,
			  0xda,0x76,0xb7,0x0b,0xf1,0x69,0x0d,0xb4,0xea,0xe2,0x9c,0x5f,0x1b,0xad,0xd0,0x3c,
			  0x5c,0xcf,0x2a,0x55,0xd7,0x05,0xdd,0xcd,0x86,0xd4,0x49,0x51,0x1c,0xeb,0x7e,0xc3,
			  0x0b,0xf1,0x2b,0x1f,0xa3,0x5b,0x91,0x3f,0x9f,0x74,0x7a,0x8a,0xfd,0x1b,0x13,0x0e,
			  0x94,0xbf,0xf9,0x4e,0xff,0xd0,0x1a,0x91,0x73,0x5c,0xa1,0x72,0x6a,0xcd,0x0b,0x19,
			  0x7c,0x4e,0x5b,0x03,0x39,0x36,0x97,0xe1,0x26,0x82,0x6f,0xb6,0xbb,0xde,0x8e,0xcc,
			  0x1e,0x08,0x29,0x85,0x16,0xe2,0xc9,0xed,0x03,0xff,0x3c,0x1b,0x78,0x60,0xf6,0xde,
			  0x76,0xd4,0xce,0xcd,0x94,0xc8,0x11,0x98,0x55,0xef,0x52,0x97,0xca,0x67,0xe9,0xf3,
			  0xe7,0xff,0x72,0xb1,0xe9,0x97,0x85,0xca,0x0a,0x7e,0x77,0x20,0xc5,0xb3,0x6d,0xc6,
			  0xd7,0x2c,0xac,0x95,0x74,0xc8,0xcb,0xbc,0x2f,0x80,0x1e,0x23,0xe5,0x6f,0xd3,0x44,
			  0xb0,0x7f,0x22,0x15,0x4b,0xeb,0xa0,0xf0,0x8c,0xe8,0x89,0x1e,0x64,0x3e,0xd9,0x95,
			  0xc9,0x4d,0x9a,0x69,0xc9,0xf1,0xb5,0xf4,0x99,0x02,0x7a,0x78,0x57,0x2a,0xee,0xbd,
			  0x74,0xd2,0x0c,0xc3,0x98,0x81,0xc2,0x13,0xee,0x77,0x0b,0x10,0x10,0xe4,0xbe,0xa7,
			  0x18,0x84,0x69,0x77,0xae,0x11,0x9f,0x7a,0x02,0x3a,0xb5,0x8c,0xca,0x0a,0xd7,0x52,
			  0xaf,0xe6,0x56,0xbb,0x3c,0x17,0x25,0x6a,0x9f,0x6e,0x9b,0xf1,0x9f,0xdd,0x5a,0x38,
			  0xfc,0x82,0xbb,0xe8,0x72,0xc5,0x53,0x9e,0xdb,0x60,0x9e,0xf4,0xf7,0x9c,0x20,0x3e,
			  0xbb,0x14,0x0f,0x2e,0x58,0x3c,0xb2,0xad,0x15,0xb4,0xaa,0x5b,0x65,0x50,0x16,0xa8,
			  0x44,0x92,0x77,0xdb,0xd4,0x77,0xef,0x2c,0x8d,0x6c,0x01,0x7d,0xb7,0x38,0xb1,0x8d,
			  0xeb,0x4a,0x42,0x7d,0x19,0x23,0xce,0x3f,0xf2,0x62,0x73,0x57,0x79,0xa4,0x18,0xf2,
			  0x0a,0x28,0x2d,0xf9,0x20,0x14,0x7b,0xea,0xbe,0x42,0x1e,0xe5,0x31,0x9d,0x05,0x68, }
		},

#if 0
		/* 32 byte key, 17 byte PTX */
		{
			32, 16, 17, SPRD_SYM_NOPAD,
			{ 0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,0xf6,0xf5,0xf4,0xf3,0xf2,0xf1,0xf0 },
			{ 0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb8,0xb7,0xb6,0xb5,0xb4,0xb3,0xb2,0xb1,0xb0 },
			//CONST64(0x123456789a),
			{ 0x12,0x34,0x56,0x78,0x9a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
			{ 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10 },
			{ 0x6c,0x16,0x25,0xdb,0x46,0x71,0x52,0x2d,0x3d,0x75,0x99,0x60,0x1d,0xe7,0xca,0x09,0xed },
		},

		/* 32 byte key, 25 byte PTX */
		{
			32, 16, 25, SPRD_SYM_NOPAD,
			{ 0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,0xf6,0xf5,0xf4,0xf3,0xf2,0xf1,0xf0 },
			{ 0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb8,0xb7,0xb6,0xb5,0xb4,0xb3,0xb2,0xb1,0xb0 },
			//CONST64(0x123456789a),
			{ 0x12,0x34,0x56,0x78,0x9a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
			{ 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
			  0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18 },
			{ 0x8f,0x4d,0xcb,0xad,0x55,0x55,0x8d,0x7b,0x4e,0x01,0xd9,0x37,0x9c,0xd4,0xea,0x22,
			  0xed,0xbf,0x9d,0xac,0xe4,0x5d,0x6f,0x6a,0x73 },
		},

		/* 32 byte key, 31 byte PTX */
		{
			32, 16, 31, SPRD_SYM_NOPAD,
			{ 0xff,0xfe,0xfd,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,0xf6,0xf5,0xf4,0xf3,0xf2,0xf1,0xf0 },
			{ 0xbf,0xbe,0xbd,0xbc,0xbb,0xba,0xb9,0xb8,0xb7,0xb6,0xb5,0xb4,0xb3,0xb2,0xb1,0xb0 },
			//CONST64(0x123456789a),
			{ 0x12,0x34,0x56,0x78,0x9a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 },
			{ 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
			  0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e },
			{ 0xd0,0x5b,0xc0,0x90,0xa8,0xe0,0x4f,0x1b,0x3d,0x3e,0xcd,0xd5,0xba,0xec,0x0f,0xd4,
			  0xed,0xbf,0x9d,0xac,0xe4,0x5d,0x6f,0x6a,0x73,0x06,0xe6,0x4b,0xe5,0xdd,0x82 },
		},
#endif
		/* 48 byte key, 32 byte PTX */
		{
			48, 16,	32, SPRD_SYM_NOPAD,
			{ 0x30,0x44,0x95,0x80,0x43,0x2F,0x1C,0xAE,0x88,0x77,0xCF,0x06,0x8E,0xE8,0x32,0x5F,
			  0x32,0x04,0x9C,0xD9,0xC0,0x83,0xCD,0x14 },
			{ 0xB2,0xDD,0xD7,0xDC,0xD5,0xC8,0xA9,0xEF,0x1D,0xB5,0xD7,0x28,0x9C,0xC5,0xFE,0xDC,
			  0xF5,0xE8,0xB0,0x7B,0xAD,0x0F,0xE9,0x97 },
			{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff },
			{ 0xEA,0x00,0xD4,0x2A,0xB3,0x82,0x3C,0x0D,0x5C,0x32,0xF2,0xFD,0x90,0xEB,0xAF,0x58,
			  0x30,0x51,0x0D,0x97,0xFD,0x62,0x2B,0x37,0x0C,0x5B,0x49,0x48,0x69,0x73,0x11,0xD3 },
			{ 0xdf,0xf2,0x87,0x01,0x12,0x43,0xa9,0x83,0x7b,0xcf,0x40,0xd5,0x90,0xda,0x5c,0xc7,
			  0x28,0xcf,0xd2,0xe2,0xd1,0x3f,0x9b,0xf1,0x11,0x39,0x46,0x41,0xf1,0x40,0x6d,0x1e },
		},

		/* 64 byte key, 32 byte PTX */
		{
			64, 16, 32, SPRD_SYM_NOPAD,
			{ 0x27,0x18,0x28,0x18,0x28,0x45,0x90,0x45,0x23,0x53,0x60,0x28,0x74,0x71,0x35,0x26,
			  0x62,0x49,0x77,0x57,0x24,0x70,0x93,0x69,0x99,0x59,0x57,0x49,0x66,0x96,0x76,0x27 },
			{ 0x31,0x41,0x59,0x26,0x53,0x58,0x97,0x93,0x23,0x84,0x62,0x64,0x33,0x83,0x27,0x95,
			  0x02,0x88,0x41,0x97,0x16,0x93,0x99,0x37,0x51,0x05,0x82,0x09,0x74,0x94,0x45,0x92 },
			{ 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff },
			{ 0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
			  0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f },
			{ 0x1c,0x3b,0x3a,0x10,0x2f,0x77,0x03,0x86,0xe4,0x83,0x6c,0x99,0xe3,0x70,0xcf,0x9b,
			  0xea,0x00,0x80,0x3f,0x5e,0x48,0x23,0x57,0xa4,0xae,0x12,0xd4,0x14,0xa3,0xe6,0x3b },
		},

		{0, 0, 0, 0, {0}, {0}, {0}, {0}, {0}}

	};

	int32_t i;
	uint8_t tmp[512];
	sprd_crypto_context_t aes;
	sprd_crypto_err_t err;

	/* encrypt */
	for (i = 0; tests[i].pt_len != 0; i++) {
		err = sprd_aes_init(SPRD_CRYPTO_AES_XTS, SPRD_CRYPTO_ENC, &aes,
				tests[i].key1, tests[i].key2, tests[i].key_len/2,
				tests[i].iv, tests[i].iv_len);
		err |= sprd_aes_process(&aes, tests[i].pt, tmp, tests[i].pt_len);
		err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
		if (err != SPRD_CRYPTO_SUCCESS
			|| sprd_pal_memcmp(tmp, tests[i].ct, tests[i].pt_len) != 0) {
			SPRD_CRYPTO_LOG_DEBUG("aes_xts encrypt test[%d] FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}
	}

	/* decrypt */
	for (i = 0; tests[i].pt_len != 0; i++) {
		err = sprd_aes_init(SPRD_CRYPTO_AES_XTS, SPRD_CRYPTO_DEC, &aes,
				tests[i].key1, tests[i].key2, tests[i].key_len/2,
				tests[i].iv, tests[i].iv_len);
		err |= sprd_aes_process(&aes, tests[i].ct, tmp, tests[i].pt_len);
		err |= sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
		if (err != SPRD_CRYPTO_SUCCESS
			|| sprd_pal_memcmp(tmp, tests[i].pt, tests[i].pt_len) != 0) {
			SPRD_CRYPTO_LOG_DEBUG("aes_xts decrypt test[%d] FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}
	}

	return SPRD_CRYPTO_SUCCESS;
}

sprd_crypto_err_t sprd_aes_test_huk (void) {
	static const struct {
		uint32_t algo;
		int32_t key_len;
		int32_t iv_len;
		int32_t pt_len;
		int32_t padding;
		const uint8_t key[32] __attribute__ ((aligned (8)));
		const uint8_t iv[16] __attribute__ ((aligned (8)));
		const uint8_t pt[192] __attribute__ ((aligned (8)));
		const uint8_t ct[192] __attribute__ ((aligned (8)));
	} tests[] = {
		{
			SPRD_CRYPTO_AES_CBC_HUK,
			16, 16, 32, SPRD_SYM_NOPAD,
			{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x40, 0x3d, 0x81, 0x5d, 0x71, 0xc2, 0x27, 0xbd,
			  0x1a, 0x23, 0x37, 0x51, 0x23, 0x5c, 0x6f, 0x28,
			  0x3d, 0x14, 0x3d, 0x8d, 0x8f, 0x9e, 0xf0, 0x3b,
			  0xa1, 0x22, 0xf1, 0x28, 0xef, 0x8f, 0x59, 0x69, },
		},
		{
			SPRD_CRYPTO_AES_CBC_HUK,
			24, 16, 32, SPRD_SYM_NOPAD,
			{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x9f, 0xf6, 0xc2, 0x57, 0x16, 0xfc, 0x68, 0x68,
			  0x24, 0xa9, 0x12, 0xe3, 0xbc, 0xdc, 0x99, 0xce,
			  0x74, 0x3d, 0xc2, 0xb1, 0x74, 0xd5, 0x99, 0xb9,
			  0x98, 0xc8, 0xae, 0xba, 0xf2, 0xff, 0x98, 0xde, },
		},
		{
			SPRD_CRYPTO_AES_CBC_HUK,
			32, 16, 32, SPRD_SYM_NOPAD,
			{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x5c, 0xa0, 0x2b, 0xaa, 0x30, 0x00, 0x05, 0x0c,
			  0x75, 0xe8, 0xf5, 0xfa, 0xb0, 0x19, 0xf5, 0xff,
			  0xb3, 0xbc, 0xdc, 0xa2, 0x0e, 0x38, 0xe9, 0xb7,
			  0x36, 0xb1, 0x22, 0x88, 0x48, 0x59, 0x64, 0x0e, },
		},
	};


	uint32_t i;
	uint8_t tmp_ct[32], tmp_pt[32];
	sprd_crypto_context_t aes;
	sprd_crypto_err_t err;

	/* encrypt */
	for (i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) {
		err = sprd_aes_init(tests[i].algo, SPRD_CRYPTO_ENC, &aes,
				NULL, NULL, tests[i].key_len,
				tests[i].iv, tests[i].iv_len);
		if (err != SPRD_CRYPTO_SUCCESS) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt test[%d] init FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}

		err = sprd_aes_process(&aes, tests[i].pt, tmp_ct, tests[i].pt_len);
		if (err != SPRD_CRYPTO_SUCCESS) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt test[%d] process FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}

		err = sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
		if (err != SPRD_CRYPTO_SUCCESS) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt test[%d] final FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}

		/* decrypt */
		err = sprd_aes_init(tests[i].algo, SPRD_CRYPTO_DEC, &aes,
				NULL, NULL, tests[i].key_len,
				tests[i].iv, tests[i].iv_len);
		if (err != SPRD_CRYPTO_SUCCESS) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt test[%d] init FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}

		err = sprd_aes_process(&aes, tmp_ct, tmp_pt, tests[i].pt_len);
		if (err != SPRD_CRYPTO_SUCCESS) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt test[%d] process FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}

		err = sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
		if (err != SPRD_CRYPTO_SUCCESS
			|| sprd_pal_memcmp(tmp_pt, tests[i].pt, tests[i].pt_len) != 0) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt test[%d] final FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}
	}

	return SPRD_CRYPTO_SUCCESS;
}

sprd_crypto_err_t sprd_aes_test_kce (void) {
	static const struct {
		uint32_t algo;
		int32_t key_len;
		int32_t iv_len;
		int32_t pt_len;
		int32_t padding;
		const uint8_t key[32] __attribute__ ((aligned (8)));
		const uint8_t iv[16] __attribute__ ((aligned (8)));
		const uint8_t pt[192] __attribute__ ((aligned (8)));
		const uint8_t ct[192] __attribute__ ((aligned (8)));
	} tests[] = {
		{ /* i = 0, test for tos kce with read */
			SPRD_CRYPTO_AES_CBC_KCE,
			16, 16, 32, SPRD_SYM_NOPAD,
			{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x40, 0x3d, 0x81, 0x5d, 0x71, 0xc2, 0x27, 0xbd,
			  0x1a, 0x23, 0x37, 0x51, 0x23, 0x5c, 0x6f, 0x28,
			  0x3d, 0x14, 0x3d, 0x8d, 0x8f, 0x9e, 0xf0, 0x3b,
			  0xa1, 0x22, 0xf1, 0x28, 0xef, 0x8f, 0x59, 0x69, },
		},
		{ /* i = 1, test for tos kce only use*/
			SPRD_CRYPTO_AES_CBC_KCE,
			16, 16, 32, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x6f, 0x75, 0x79, 0x7d, 0x05, 0xd8, 0xf4, 0xbf,
			  0x27, 0x80, 0xd8, 0xe4, 0x29, 0x02, 0xa9, 0x8f,
			  0xfd, 0x46, 0xf1, 0x35, 0x03, 0x94, 0x87, 0x98,
			  0x4a, 0x95, 0x6c, 0x94, 0xb1, 0xb0, 0xb1, 0x8d, },
		},
		{ /* i = 1, test for tos kce only use*/
			SPRD_CRYPTO_AES_CBC_KCE,
			16, 16, 32, SPRD_SYM_NOPAD,
			{ 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,
			  0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, },
			{ 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
			  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, },
			{ 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
			  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
			  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
			  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, },
			{ 0x5f, 0xb0, 0x51, 0x9f, 0x53, 0xce, 0xc4, 0x66,
			  0x53, 0x0a, 0x8b, 0xea, 0x34, 0x5b, 0x2f, 0x72,
			  0x4a, 0x03, 0xd8, 0x4f, 0x64, 0xef, 0x96, 0xf4,
			  0xbe, 0xfd, 0xe9, 0xd2, 0x01, 0x37, 0xf0, 0xa7 },
		},
	};

	uint32_t i;
	uint8_t tmp_ct[32], tmp_pt[32];
	sprd_crypto_context_t aes;
	sprd_crypto_err_t err;

	SPRD_CRYPTO_LOG_ERR("tos_kce_test start.\n");
	/* encrypt */
	for (i = 2; i < sizeof(tests)/sizeof(tests[0]); i++) {
		err = sprd_aes_init(tests[i].algo, SPRD_CRYPTO_ENC, &aes,
				tests[i].key, NULL, tests[i].key_len,
				tests[i].iv, tests[i].iv_len);
		if (err != SPRD_CRYPTO_SUCCESS) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt test[%d] init FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}

		err = sprd_aes_process(&aes, tests[i].pt, tmp_ct, tests[i].pt_len);
		if (err != SPRD_CRYPTO_SUCCESS) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt test[%d] process FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}

		err = sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
		if (err != SPRD_CRYPTO_SUCCESS
			|| sprd_pal_memcmp(tmp_ct, tests[i].ct, tests[i].pt_len) != 0) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc encrypt test[%d] final FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}

		/* decrypt */
		err = sprd_aes_init(tests[i].algo, SPRD_CRYPTO_DEC, &aes,
				tests[i].key, NULL, tests[i].key_len,
				tests[i].iv, tests[i].iv_len);
		if (err != SPRD_CRYPTO_SUCCESS) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc decrypt test[%d] init FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}

		err = sprd_aes_process(&aes, tests[i].ct, tmp_pt, tests[i].pt_len);
		if (err != SPRD_CRYPTO_SUCCESS) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc decrypt test[%d] process FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}

		err = sprd_aes_final(&aes, NULL, 0, NULL, NULL, SPRD_SYM_NOPAD);
		if (err != SPRD_CRYPTO_SUCCESS
			|| sprd_pal_memcmp(tmp_pt, tests[i].pt, tests[i].pt_len) != 0) {
			SPRD_CRYPTO_LOG_ERR("aes_cbc decrypt test[%d] final FAILED\n", i);
			return SPRD_CRYPTO_ERR_RESULT;
		}
	}
	SPRD_CRYPTO_LOG_ERR("tos_kce_test success.\n");

	return SPRD_CRYPTO_SUCCESS;
}

sprd_crypto_err_t sprd_aes_test (void) {
	sprd_crypto_err_t err = SPRD_CRYPTO_SUCCESS;
	int32_t aes_ecb = 0, aes_cbc = 0, aes_ctr = 0, aes_xts = 0, aes_huk = 0, aes_kce = 0, aes_ctr_hdcp = 0;

	err = sprd_aes_test_ecb();
	if (err != SPRD_CRYPTO_SUCCESS) {
		SPRD_CRYPTO_LOG_ERR("****sprd_aes_test_ecb FAILED!****\n");
		goto failed;
	} else {
		aes_ecb = 1;
	}

	err = sprd_aes_test_cbc();
	if (err != SPRD_CRYPTO_SUCCESS) {
		SPRD_CRYPTO_LOG_ERR("****sprd_aes_test_cbc FAILED!****\n");
		goto failed;
	} else {
		aes_cbc = 1;
	}

	err = sprd_aes_test_ctr();
	if (err != SPRD_CRYPTO_SUCCESS) {
		SPRD_CRYPTO_LOG_ERR("****sprd_aes_test_ctr FAILED!****\n");
		goto failed;
	} else {
		aes_ctr = 1;
	}

	err = sprd_aes_test_ctr_hdcp();
	if (err != SPRD_CRYPTO_SUCCESS) {
		SPRD_CRYPTO_LOG_ERR("****sprd_aes_test_ctr_hdcp FAILED!****\n");
		goto failed;
	} else {
		aes_ctr_hdcp = 1;
	}

	err = sprd_aes_test_xts();
	if (err != SPRD_CRYPTO_SUCCESS) {
		SPRD_CRYPTO_LOG_ERR("****sprd_aes_test_xts FAILED!****\n");
		goto failed;
	} else {
		aes_xts = 1;
	}

#if 0
	err = sprd_aes_test_huk();
	if (err != SPRD_CRYPTO_SUCCESS) {
		SPRD_CRYPTO_LOG_ERR("****sprd_aes_test_huk FAILED!****\n");
		goto failed;
	} else {
		aes_huk = 1;
	}
#endif

#if 0
	err = sprd_aes_test_kce();
	if (err != SPRD_CRYPTO_SUCCESS) {
		SPRD_CRYPTO_LOG_ERR("****sprd_aes_test_kce FAILED!****\n");
		goto failed;
	} else {
		aes_kce = 1;
	}
#endif

failed:
	if (aes_ecb == 1) {
		SPRD_CRYPTO_LOG_WARN("sprd_aes_test_ecb pass!\n");
	}

	if (aes_cbc == 1) {
		SPRD_CRYPTO_LOG_WARN("sprd_aes_test_cbc pass!\n");
	}

	if (aes_ctr == 1) {
		SPRD_CRYPTO_LOG_WARN("sprd_aes_test_ctr pass!\n");
	}

	if (aes_ctr_hdcp == 1) {
		SPRD_CRYPTO_LOG_WARN("sprd_aes_test_ctr hdcp pass!\n");
	}

	if (aes_xts == 1) {
		SPRD_CRYPTO_LOG_WARN("sprd_aes_test_xts pass!\n");
	}

	if (aes_huk == 1) {
		SPRD_CRYPTO_LOG_WARN("sprd_aes_test_huk pass!\n");
	}

	if (aes_kce == 1) {
		SPRD_CRYPTO_LOG_WARN("sprd_aes_test_kce pass!\n");
	}
	return err;
}

/*
STATIC_COMMAND_START
STATIC_COMMAND("sprd_aes_test", "ce algorithm aes test", (console_cmd)&sprd_aes_test)
#ifdef CE_PERFORMANCE_TEST
STATIC_COMMAND("sprd_aes_speed_test", "ce algorithm aes test", (console_cmd)&sprd_aes_speed_test)
#endif
STATIC_COMMAND_END(sprd_aes_test);
*/
